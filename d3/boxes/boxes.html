<!doctype html>
<title>Q_[2] covering</title>
<body>

<script src='http://d3js.org/d3.v4.min.js'></script>
<script src="https://d3js.org/d3-selection-multi.v0.4.min.js"></script>

<script> d3.select('body').append('h1').text(d3.select('title').text()) </script>

<script>
  /*
    Input format:

    coord [1,2,3,4] [1,2,3,4]   -- coordinate space box, piece of fund. domain
    bound [1,2,3,4] [1,2,3,4]   -- bounding box in MS space
    cull [1,2,3,4] [1,2,3,4]    -- culled box
    good [1,2,3,4] [1,2,3,4] [1,2,3,4] ....  -- good box, with multiple CS points

    Also, input for the transformation CS -> MS:

    [ [1,2,3,4],
      [1,2,3,4],
      [1,2,3,4],
      [1,2,3,4] ]

   */
</script>

<style>
  body { background: #ddd; font-size: 100%; padding: 1em; }
  h1 { text-align: center; }
  path { fill: none; stroke:#000; stroke-width:3px; }
  circle { fill: #ff0; opacity: 0.66; stroke: #000; strike-width: 2px; }
  svg { background: #ccc; }
  .center { display: flex; align-items: center; justify-content: center; }
  .grid line { stroke: #aaa; shape-rendering: crispEdges; }
  .grid path { stroke-width: 0; }
  .good-boxes { fill: #8f8; stroke: #000; stroke-width: 1; }
  .culled-boxes { fill: #f88; stroke: #000; stroke-width: 1; }
  .hyperboloids { stroke: #000; opacity: 0.5; }
  .vbox { display: flex; flex-direction: column; align-items: center; }
  .framed { outline: thin solid black; }
</style>

<div id='svg-parent' class='center'></div>

<div class='slidecontainer center'>
  <div class='vbox'>
    <input id='x2' type='range' min='-2' max='2' step='0.01' value='0' class='slider'>
    <span>x2 = <span id='x2value'>-</span></span>
  </div>
  <div class='vbox'>
    <input id='x3' type='range' min='-2' max='2' step='0.01' value='0' class='vslider'>
    <span>x3 = <span id='x3value'>-</span></span>
  </div>
</div>

<div id='x23box' class='center'></div>

<script>
  var F = fld => obj => obj[fld]
  var compose = (g,h) => (d) => g(h(d))

  var zip = (xs,ys) => xs.map((x,i) => [x,ys[i]]),
      zipWith = (f) => (xs, ys) => xs.map((x,i) => f(x, ys[i])),
      vadd = zipWith((x,y) => x+y),
      vsub = zipWith((x,y) => x-y),
      vmul = zipWith((x,y) => x*y),
      vabs = (xs) => xs.map(Math.abs),
      vmin = (xs) => Math.min(...xs),
      vmax = (xs) => Math.max(...xs)

  var pi = Math.PI, cos = Math.cos

  var C2M = [[1,1,1,1]].concat(
      d3.range(1,4).map(
          i => d3.range(1,9,2).map(
              j => 2*cos(2*pi*i*j/16))))

  var M2C = [[0.25,  0.230969883128,   0.176776695297,  0.0956708580912],
             [0.25,  0.0956708580912, -0.176776695297, -0.230969883128],
             [0.25, -0.0956708580912, -0.176776695297,  0.230969883128],
             [0.25, -0.230969883128,   0.176776695297, -0.0956708580912]]

  var x2 = 0, x3 = 0

  d3.select("#x2").on("input", function(d) {
      x2 = this.value
      d3.select('#x2value').text(x2)
      update() })

  d3.select("#x3").on("input", function(d) {
      x3 = this.value
      d3.select('#x3value').text(x3)
      update() })

  var margin = {top: 0, right: 0, bottom: 0, left: 0},
      width = 600 - margin.left - margin.right,
      height = 600 - margin.top - margin.bottom

  var svg = d3.select('#svg-parent')
      .append('div')
        .append('svg')
          .attr('width', width + margin.left + margin.right)
          .attr('height', height + margin.top + margin.bottom)
          .call(d3.zoom().on('zoom', () => svg.attr('transform', d3.event.transform)))
        .append('g')
          .attr('transform',
                'translate(' + margin.left + ',' + margin.top + ')');

  var x = d3.scaleLinear().range([0,width]).domain([-5,5]),
      y = d3.scaleLinear().range([height,0]).domain([-5,5]),
      line = d3.line().x(compose(x,F(0))).y(compose(y,F(1)))

  { var grid = svg.append('g').attr('class', 'grid')
    grid.append('g').call(d3.axisBottom().scale(x).tickSizeInner(height))
    grid.append('g').call(d3.axisRight().scale(y).tickSizeInner(width)) }

  var dx = (x0,x1) => x(x1) - x(x0), // for rectangle width (user -> svg)
      dy = (y0,y1) => y(y0) - y(y1)  //          and  height (user -> svg)

  {
      let width = 100, height = 100
      var svgx23 = d3.select('#x23box')
          .append('div').attr('class','framed')
          .append('svg')
          .attrs({width: width, height: height})

      let x = d3.scaleLinear().range([0,width]).domain([-2,2]),
          y = d3.scaleLinear().range([height,0]).domain([-2,2])

      const dragHandler = d3.drag().on('drag', dragged)

      function dragged() {
        var current = d3.select(this)
        current.attrs({cx: d3.event.x, cy: d3.event.y})
        x2 = x.invert(d3.event.x), x3 = y.invert(d3.event.y)
        update() }

      var circle = svgx23.append('circle')
          .attr('r', 5)
          .attr('cx', x(0))
          .attr('cy', y(0))
          .call(dragHandler)

      function circle_update () {
          circle.attr('cx', x(x2)).attr('cy',y(x3)) }
  }

  var box_attrs = { // can be reused for all our box types
      class: 'box',
      x: d => x(d.pt[0]),
      y: d => y(d.pt[1]),
      width: d => dx(0, d.sides[0]),
      height: d => dy(0, d.sides[1]) }

  var good_boxes = [ { pt: [-1,-1,0,0], sides: [0.5,0.25,2,2] },
                     { pt: [-2,-1.5,0,0], sides: [0.25,0.25,1,1] },
                     { pt: [-3,-1.8,0,0], sides: [0.25,0.25,0.5,0.5] } ]

  var culled_boxes = [ { pt: [1,1,0,0], sides: [0.333,0.333,2,2] },
                       { pt: [-3,2,0,0], sides: [0.25,0.25,1,1] } ]

  var hyperboloids = [ [0.01,0.01,0.01,0.01], [1.01,1.01,1.01,1.01] ]

  var bbox   = svg.append('g').attr('class', 'bounding-box')
  var gboxes = svg.append('g').attr('class', 'good-boxes')
  var cboxes = svg.append('g').attr('class', 'culled-boxes')
  var hypers = svg.append('g').attr('class', 'hyperboloids')

  // xs.concat(ys)

  function update () {

      var is_visible = (d) =>
          x2 >= d.pt[2] && x2 <= d.pt[2] + d.sides[2] &&
          x3 >= d.pt[3] && x3 <= d.pt[3] + d.sides[3];

      d3.select('#x2value').text(Number(x2).toFixed(2))
      d3.select('#x3value').text(Number(x3).toFixed(2))
      circle_update()

      var hyp = []

      gboxes.selectAll('rect').remove()
      gboxes.selectAll('rect')
          .data(good_boxes)
          .enter()
          .filter(is_visible)
          .append('rect')
          .attrs(box_attrs)

      cboxes.selectAll('rect').remove()
      cboxes.selectAll('rect')
          .data(culled_boxes)
          .enter()
          .filter(is_visible)
          .append('rect')
          .attrs(box_attrs)

      hypers.selectAll('path').remove()
      hypers.selectAll('path')
          .data(hyperboloids.map(function (d) { return draw_hyp(d); }))
          .enter()
          .append('path')
          .attr('d', line)
          .style('fill', '#ff8') // why doesn't css work?
          .style('opacity', '0.2')
  }

  function draw_hyp (v) {

      let a = v[0], b = v[1], bd = 1.0
      let z = (v[2] - x2) * (v[3] - x3) / bd
      let dx = 1/50.0, steps = 1000

      var quadrant = (x0, dx, sy) => {
          return d3.range(0, steps-1).map((i) => {
              let x = x0 + i*dx; return [x, b + sy*1/z/(x-a) ]; }) }

      return quadrant(a+dx, dx, +1)
          .concat(quadrant(a+steps*dx, -dx, -1))
          .concat(quadrant(a-dx      , -dx, +1))
          .concat(quadrant(a-steps*dx, +dx, -1)) }

  function coord_proj (cb) {
      

  }


  update()

</script>
